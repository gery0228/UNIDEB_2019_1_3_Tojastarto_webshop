ökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerintem
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása............................................................................................................................ 3
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.............................................................. 3
[3]. Adatszerkezetek reprezentációja, ábrázolási módok................................................................................................. 4
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket! ........................................................................................ 4
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is! ....................................................... 5
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!................................................................................. 7
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!.. 8
[8]. Ismertesse a lista adatszerkezetekel! ................................................................................................................................ 10
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!.................................................................... 11
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!............................................................ 13
[11]. Ismertesse a fa adatszerkeztet! ........................................................................................................................................ 14
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit! ........................................................................................ 15
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!) .......................................................................................................................................................... 17
[14]. Ismertesse a B-fa adatszerkezetet .................................................................................................................................. 18
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!................................... 19
[16]. Műveletek állományokkal, állományok osztályozása......................................................................................... 21
[17]. A szeriális, szekvenciális, direkt és a random állomány. .................................................................................. 22
[18]. Összetett állománykezelési technikák (láncolás, indexelés). ........................................................................ 24
[19]. Indexelt szeriális és szekvenciális állomány!........................................................................................................... 25
[20]. Invertált állományok! ............................................................................................................................................................. 26
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!................................................. 27
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során? ............................................................................................................................................ 27
[3]. Ismertesse röviden a speciális halmaz műveleteket! .............................................................................................. 27
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!.......................................................................... 28
[5]. Ismertesse röviden a verem adatszerkezetet! ............................................................................................................. 28
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?........................................................................................................................................................................................... 28
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának? ................................................................................................................................................ 29
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját! ............................................................................... 29
[9]. Jellemezze röviden a sztring adatszerkezetet!............................................................................................................. 29
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek? .............. 30
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i........................................... 30
[12]. Jellemezzen röviden három mintaillesztő algoritmust! .................................................................................... 31
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)................................ 31
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!...................................................................................................... 32
[15]. Ismertesse röviden a rekord adatszerkezetet! ....................................................................................................... 32
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés? ................................................................................................................................ 32
[17]. Ismertesse a röviden a kupac adatszerkezetet! ..................................................................................................... 32
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit! ............................................................................. 33
[19]. Jellemezze röviden a sor adatszerkezetet! ................................................................................................................ 33
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait! ................................................................. 34
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak? .................................................... 34
NAGY KÉRDÉSEK
[1]. Absztrakt adatszerkezetek osztályozása.
Adatelemekből állnak.
Ezek lehetnek:
- egyszerűek (atomiak)
- összetettek
Az adatelem:
- egyszerű: 1 értéke van
- összetett: egy értékcsoport alkotja az értékét
1. Adatelemek száma változik-e időben
- statikus
- dinamikus
2. Adatelemek típusa
- homogén (az összes adatelem típusa azonos)
- heterogén
Ez a két szempont ortogonális, azaz egymástól teljesen független.
3. Adatelemek közötti kapcsolat szerint:
- homogén adatszerkezetben
o struktúra nélküli (nincs kapcsolat, pl.: halmaz)
o asszociatív (pl.: tömb)
o szekvenciális (minden a.e. két másik a.e.-el van kapcsolatban, kivéve az elsőt és az utolsót, minden adatelemnek van egy megelőzője és egy rákövetkezője)
o hierarchikus (minden adatelemnek egy megelőzője és akárhány rákövetkezője van, pl. FA)
o hálós (minden adatelemnek tetszőleges számú megelőzője és rákövetkezője lehet)
- heterogén adatszerkezet esetén nem csoportosítunk a kapcsolatok szerint, mindig rekord adatszerkezetről beszélünk.
[2]. Ismertesse az absztrakt adatszerkezetekkel végezhető műveleteket.
- Létrehozás
o Az üres szerkezeti váz kialakítása az adatelemek értékei is megadhatóak
- Módosítás
o nem érinti a szerkezetet csak az egyes adatelemeket
o bővítés (dinamikus adatszerkezeteknél)
o törlés (fizikai és logikai) (csak din. ad.sz.)
o csere (meglévő a.e. értékét felülírjuk)
- Rendezés
o segítségével az adatszerkezet elemeit egy (elsődleges) kulcs értékei alapján sorba rendezzük.
o szélsőérték kiválasztásos
o beszúrásos
o buborék
o shell
o gyors
- Keresés
o teljes
o lineáris (rendezett)
o bináris (rendezett, folytonos tárolású)
- Elérés
o segítségével hozzá tudunk férni, meg tudjuk fogni az adatszerkezet egy elemét
o közvetlen (többi adatelemtől független elérés)
o szekvenciális (adatelemek közötti kapcsolat alapján)
- Bejárás
o melyek során az összes elemet érintjük
- Feldolgozás
o hozzáférünk az a.e.-ekben tárolt információhoz, azokon valamilyen tevékenységet hajtunk végre
[3]. Adatszerkezetek reprezentációja, ábrázolási módok.
- Folytonos (vektorszerű)
o Egy tárhely – egy adatelem értéke
o A tárhelyek a memóriában egy folytonos, összefüggő tárterületet alkotnak, a tárhelyek mérete azonos
o Előnyei:
 közvetlen elérés, a kezdőcím és a tárhely mérete alapján
 csere műveletet könnyű megvalósítani
 hatékony rendező algoritmusok
 hatékony kereső algoritmusok
o Hátránya:
 nem segíti a bővítést és a fizikai törlést
- Szétszórt (láncolt)
o A tárhelyen az adatelem értéke (érték rész) mellett legalább egy mutató (mutató rész) értékét tároljuk.
o Mutató: tipikusan memóriacím
o Fajtái:
 egyirányban láncolt lista
 kétirányban láncolt lista
 cirkuláris lista
 multilista
[4]. Ismertesse a halmaz és multihalmaz adatszerkezeteket!
- Halmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o A halmaz, mint absztrakt adatszerkezet megfelel a matematikai halmaz fogalomnak. Így pl.
o nincs benne ismétlődő elem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
- Halmazokra értelmezett műveletek
o ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
o UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Összehasonlítás:
 Egyenlőség
 Valódi és
 „nem valódi” részhalmaz
- Halmaz adatszerkezet műveletei
LÉTREHOZÁS
Felsorolás segítségével megadjuk a halmaz elemeit (szék, asztal, tábla, pad, …)
Megadunk egy olyan „predikátumot”, amely alapján minden elemről eldönthető, eleme-e a halmaznak (A … teremben is megtalálható bútorfajták.)
BŐVÍTÉS
Minden esetben az unióképzés, mint halmazművelet segítségével történik.
CSERE
Nem értelmezett, NINCS. (Tágabb értelemben esetleg: Törlés + bővítés.)
LOGIKAI TÖRLÉS
Nem értelmezett, NINCS.
FIZIKAI TÖRLÉS
A különbségképzés halmazművelettel valósítható meg.
RENDEZÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
ELÉRÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
KERESÉS
Nem értelmezett. (Struktúra-nélküliség miatt.)
FELDOLGOZÁS
Az alap halmazműveletekkel történik.
- Multihalmaz adatszerkezet
o Dinamikus és homogén adatszerkezet.
o Az adatelemek között nincs kapcsolat, így
o nem beszélhetünk az elemek sorrendjéről sem.
o Van üres halmaz.
o Szemben a matematikai halmaz fogalommal, a halmaz adatszerkezetben nem engedünk meg végtelen számosságú halmazt.
o A multihalmaz abban különbözik a halmaztól, hogy megenged azonos elemeket is, azaz egy adott elem nem csak 0-szor vagy 1-szer fordulhat elő, hanem többször is.
- Multihalmazok műveletei
o ELEME ( ): nincs eltérés; (lehet picit másként is.)
o UNIÓ KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazokban együttesen szerepel. (összeg, de elképzelhető maximum is)
o METSZET KÉPZÉS ( ): egy adott értékű elem annyiszor fog szerepelni az unióban, ahányszor a kiinduló multihalmazok mindegyikében szerepel. (minimum)
o KÜLÖNBSÉGKÉPZÉS ( ): adott elem a kiinduló multihalmazokban való előfordulásainak különbségeszer fog előfordulni, ha a baloldali multihalmazban fordul elő többször. Egyébként 0-szor. (kivonás)
[5]. Ismertesse a tömb adatszerkezeteket! Térjen ki a speciális esetekre is!
- Statikus és homogén, asszociatív adatszerkezet.
- Az egyik leggyakrabban használt adatszerkezet, amelyet
- A felépítése definiál, és amelyben
- Az adatelemek egymáshoz viszonyított helyzete a lényeges.
- A tömb bármely eleme egész számok egy sorozatán keresztül érhető el.
- Minden adatelemhez különböző egész szám sorozat tartozik: az asszociativitást biztosító részhalmazok diszjuktak és egy eleműek.
- A szám sorozat elemeit a tömb indexeinek nevezzük.
- Az indexek számát dimenziónak hívjuk.
Egydimenziós tömb (Vektor):
- Rögzítjük az első elem helyét,
- A többi elem helyét ehhez viszonyítjuk
- Ha mást nem mondunk, az indexek értéke 1-től indul.
- Vektor (jelzők nélkül) == > számunkra, 1 dimenziós statikus tömb
Kétdimenziós tömb (Mátrix)
- Itt is az első elemhez viszonyítjuk a többit
- Beszélünk sorokról és oszlopokról
- A dimenziók száma tetszőleges, de mindig véges
A tömb adatszerkezet műveletei
LÉTREHOZÁS
Rögzítjük a dimenziók számát, az egyes dimenziókhoz tartozó indexek tartományát, és ezáltal az elemek számát
A szerkezet kialakításával párhuzamosan esetleg elemeket is elhelyezhetünk a szerkezetben.
BŐVÍTÉS
NINCS. (Statikus adatszerkezet.)
CSERE
Elem elhelyezése oda, ahová nem tettünk a létrehozásakor
Hagyományosan: létező elem értékét felülírjuk
LOGIKAI TÖRLÉS
Speciális CSERE műveletként értelmezhető
FIZIKAI TÖRLÉS
NINCS. (Statikus adatszerkezet.)
RENDEZÉS
Általában nem értelmezett. Vektoroknál (1 dimenziós tömb) viszont igen.
BEJÁRÁS
Értelmezhető művelet, de reprezentáció-függő
KERESÉS
A közvetlen elérés miatt általában nem beszélünk keresésről. Teljes keresés. (Amikor nem általában…..) Rendezett vektor esetében viszont van értelme. Ilyenkor bármelyik kereső algoritmus alkalmazható.
FELDOLGOZÁS
Alapja a közvetlen elérés
- Speciális esetek
o Háromszögmátrix
 Ha négyzetes (vagy kvadratikus) mátrix főátlója alatt vagy felett csupa 0 elem található, azt háromszögmátrixnak nevezzük.
 Megkülönböztetünk alsó és felső háromszögmátrixot, méghozzá aszerint, hogy hol helyezkednek el a nem-nulla értékű elemei
 Felső háromszögmátrix: főátlójában és felette tetszőleges elemek lehetnek (ezek a lényeges (fő) elemek). Ezek darabszáma: n(n+1)/2. Ez csak kicsit több mint a mátrixban összesen elhelyezhető elem fele (n2/2).
 Éppen ezért, ha speciálisan tudjuk tárolni (csak az értékes elemeket), azzal tárhelyet tudunk spórolni.
o Szimmetrikus mátrix
 Az olyan négyzetes (vagy kvadratikus) mátrixot, melynek „szimmetrikus elemei„ megegyezőek, szimmetrikus mátrixnak nevezzük: Ai,j =Aj,i
 Ezek helytakarékos ábrázolása hasonlóan oldható meg, mint a háromszögmátrixoké.
o Ritka mátrixok
 Ritka mátrixnak nevezzük az olyan 2 dimenziós (tetszőleges méretű) tömböt, amelyben sok azonos értékű elem (leggyakrabban 0) szerepel, és a sok azonos értékű elem között a tőlük különböző értékű elemek véletlenszerűen helyezkednek
el. A ritka mátrixokat akkor érdemes külön (egyedi módszerekkel) kezelni, ha nagy az elemszáma és ezen belül arányában is nagy az azonos értékű elemek száma.
 A megoldandó probléma u.a. mint az előbb. Cél: a tárhelyek megtakarítása
o Dinamikus tömb
 Dinamikus tömb -bármilyen meglepő is ez- egy dinamikus alapszerkezet.
 Általában egydimenziós tömböket értünk alatta, más szóval: dinamikus vektorok.
 Ennél az adatszerkezetnél létezik a bővítés és a fizikai törlés művelete.
 Egyébiránt minden olyan információ igaz rá, amiket a tömbnél elmondtunk.
 Szűkebb értelemben a dinamikus tömb elemeinek száma mindig egy aktuális elemszám, amely nem a létrehozással, hanem a használat során alakul ki.
 Bővítéskor ebbe a tömbbe új elemet viszünk föl.
 Ez azt jelenti, hogy mindig az aktuális elemszámnak megfelelő tárhelyet foglalunk le.
 Tágabb értelemben az aktuális méretet explicit módon adhatjuk meg, átméretezhetjük a tömböt, amelyben így léteznek olyan helyek ahol van elem, és maradhatnak olyanok, amelyek üresek.
 Ebben az értelemben fizikai törlést követően a dinamikus tömbben lyukak lehetnek (maradhatnak).
 Egydimenziós tömbök segítségével az összes homogén adatszerkezet (a tömb önmaga is) szimulálható.
[6]. Ismertesse a soros, önátrendező és rendezett táblázatokat!
- Soros táblázatok
LÉTREHOZÁS
Az elemek táblázatbeli sorrendjét egy időbeli sorrend adja.
Meg kell mondanunk a kulcs és az adatrész típusát, majd ezt követően az elemek érkezési sorrendjében töltjük fel a táblázatot.
BŐVÍTÉS
Az egyik végén történik. Fontos: Az új kulcs valóban új kell legyen!
CSERE
Az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
TÖRLÉS
Tetszőleges elemet törölhetünk úgy, hogy megkeressük a törlendő elemet, és azt az utolsó elemmel felülírjuk, egyúttal 1-gyel csökkentjük a táblázat elemszámát.
Ez a technika folytonos ábrázolás esetén is alkalmazható.
Szétszórt ábrázolás esetén más megoldások is használhatóak.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Soros
KERESÉS
Teljes keresés, a kulcs alapján történik
FELDOLGOZÁS
Alapja a kulcs és a teljes keresés
Ábrázolása lehet folytonos és szétszórt egyaránt. Hol használatos? Ahol az adathalmaz minden elemét meg kell tudni különböztetni egymástól. Hátránya: Ha nem azonos az elemek feldolgozási gyakorisága, akkor a használat nem gazdaságos.
- Önátrendező táblázat
o A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
o Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
o Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
o Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
 a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
 ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
o A többi elem egymáshoz viszonyított sorrendje változatlan marad.
o Az utoljára feldolgozott elem a táblázat elejére kerül.
o Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
o Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
- Rendezett táblázat
o A rendezett táblázat elemei a kulcs alapján rendezettek. A feldolgozás gyorsítása érdekében alkalmazzuk ezt az adatszerkezetet.
o Az adatelemek sorrendjét a kulcsok szerinti növekedési sorrend definiálja. Létrehozása és bővítése beszúró rendezéssel történik.
o Csere: Ugyanúgy mint a korábbi táblázatoknál.
o Megfelelő ábrázolás mellett többféle keresési algoritmus használható.
o Többnyire a lineáris és bináris a praktikus választás.
o Folytonos ábrázolásnál gyorsabb a keresés, viszont problematikus a bővítés és a fizikai törlés.
o Szétszórt ábrázolásnál pedig pont fordított a helyzet.
[7]. Ismertesse a kulcstranszformációs táblázatokat! Térjen ki a szinonimakezelés módszereire is!
- Kulcstranszformációs táblázat
o Ábrázolása folytonos
o Soros táblázat esetén egy elem helyét a beszúrás időpontja, önátrendező táblázatnál a feldolgozás gyakorisága, rendezett táblázatnál a kulcs értéke szabja meg
o Egy elem helyét a k kulcs valamilyen f(k)-val jelölt függvénye alapján határozhatjuk meg.
o Ezt a függvényt hívjuk hasító vagy hash függvénynek.
o Az eljárást magát (elem kulcsához meghatározzuk az f(k) értéket) hashingnak vagy randomizálásnak vagy kulcstranszformációnak vagy hasításnak nevezzük.
o A hash-függvény a kulcsokat képezi le tárbeli címekre.
o Kulcstranszformáció esetén beszélünk a kulcsok elvi előfordulási lehetőségeiről, és a gyakorlatban ténylegesen megvalósuló kulcsértékekről.
o A hash-függvény lehet kölcsönösen egyértelmű (ideális eset).
o Ez akkor valósítható meg, ha az elvi és a gyakorlati lehetőségek száma közel megegyezik, vagy a gyakorlatban előforduló kulcsok egyenletesen oszlanak el az elvi lehetőségen belül. (Ideális eset, csak ritkán fordul elő)
o Ha az elvi és a gyakorlati lehetőségek között nagy a különbség és nem egyenletes az eloszlás, akkor csak egyértelmű hash függvények léteznek.
o Egy-egy hash-függvénytől a következő dolgokat várjuk el:
 helyezze le a kulcsokat a rendelkezésre álló címtartományra;
 ezen a címtartományon próbálja meg egyenletessé tenni az eloszlást
o Általában elmondhatjuk, hogy univerzális hash-függvény, ami ezeket garantálja, nincs.
LÉTREHOZÁS
Szinonima kezelési technika választása, Hash-függvény választás (szempontjai már voltak).
A gyakorlatban előforduló kulcsok számára adni kell valamilyen becslést, majd tárhelyet kell foglalni a leendő elemek számára (1., 2.: +10% ; 3: annyi, amennyi), és végül az elemek elhelyezése a tárban.
BŐVÍTÉS
Kulcsok alapján a Hash-függvény segétségével, és az előzőekben említettek figyelembe vételével történik.
CSERE
Kulcs alapján megoldható. Értékeit lehet cserélni bármikor. A kulcs cseréje törléssel és bővítéssel megoldható.
TÖRLÉS
Logikai törlés: Minden módszer esetén működik.
Fizikai törlés: A harmadik módszernél a független túlcsrdulási listákban elhelyezett elemek esetében lehetséges.
RENDEZÉS
Nincs (nem értelmezett)
ELÉRÉS
Kvázi közvetlen, hiszen a Hash-függvény a közvetlen elérést szolgálja. A szinonimákat viszont keresni kell.
KERESÉS
A szinonimakezelési módszertől függ.
FELDOLGOZÁS
Alapja a Hash-függvény, illetve rajta keresztül a „kvázi közvetlen” elérés.
- Szinonima, szinonimakezelési módszerek
o A legtöbb esetben előfordul, hogy különböző kulcsokhoz ugyanazt a címet rendeli. Ekkor szinonimákról beszélünk.
o A szinonimák felbukkanását valahogy kezelni kell, mert egy helyen a tartományban csak egy elemet tudok elhelyezni.
o A nyílt címzés módszere
 A nem túlcsordult és a túlcsordult elemeket ugyanazon tárhely sorozatban kell elhelyezni. (Folytonos tárolás)
 Ha valahol túlcsordulást tapasztalunk, akkor az adott helyről elindulunk a tárhelyek vége felé, és keressük az első üres tárhelyet, ahová bepakoljuk a túlcsordult elemet. Amennyiben elérjük a tár végét akkor az üres hely keresését az 1. tárhelytől kezdve folytatjuk tovább.
 Láncolással történő nyílt címzés módszere
 Független túlcsordulási lista alkalmazása
 Egy adatelemet kulcs alapján visszakeresni ezután a Hash-függvény segítségével úgy lehet, hogy ha az adott kulcsú elem nincs a Hash-függvény által adott címen (tárhelyen), akkor egy teljes keresést kell végrehajtani az 1. üres helyig, vagy amíg meg nem találjuk a keresett elemet.
 Ha a keresés közben elérjük a tartomány végét (utolsó tárhelyét), akkor a keresést a tárhely elején folytatjuk tovább.
 A keresést megállíthatja még az is, hogy anélkül érünk vissza a kiinduló helyzethez, hogy a keresett elemet megtaláltuk volna.
 A kulcstranszformációs táblázatnál nyílt címzés módszerével problémát jelenthet, hogy egy túlcsorduló rekord túlcsordulttá tehet egyébként nem túlcsorduló elemeket is.
 A probléma megoldása az lehet, ha az elemeket két lépesben helyezzük el a táblázatban.
 Első körben azokat, amelyek szabályosan a helyükre pakolhatók,
 majd ezek után a kimaradókat (ezek mindegyike túlcsordult lesz majd).
 Nyílt címzés esetén egy elem a tárhelyről fizikailag semmiképpen sem törölhető, ugyanis a helyén maradó üres tárhely megállítaná a keresést. Emiatt az ilyen kulcstranszformációs táblázatban egy tárhelynek három állapota lehet attól függően, hogy érvényes elemet, vagy (logikailag) törölt elemet tartalmaz, vagy egyszerűen üres.
 Új elem beszúrásakor az új elemet üres vagy legalább törölt helyre szúrjuk be.
o Láncolással történő nyílt címzés módszere
 A nyílt címzéssel történő szinonima kezelés hátránya: túlcsordult elemek esetén az elem elsődleges helyén (ahová a Hash-függvény leképezné) nincs semmi információ az elem tényleges helyére vonatkozóan.
 Ezt javítja egy másik szinonimakezelési technika, a láncolással történő nyílt címzés módszere.
 A tárhely eddigi két oszlopa (kulcs és adat) mellé fel kell venni egy harmadikat. A mutató oszlopban található értékek megadják az adott helyről, vele azonos hash-értékű kulccsal először túlcsorduló elem címét (sorszámát). Ezen értékek segítségével a szinonim elemeket egy-egy láncban fűzzük fel. Amennyiben a mutató mezőben található érték NIL vagy nulla értékű, akkor az adott tárhelyről (ugyanazon hash-értékű kulccsal) nem történt túlcsordulás – vagy már törölve lett a túlcsorduló elem.
 A szinonimák a láncon keresztül gyorsan elérhetők, viszont nő a tárfoglalási és a karbantartási idő.
 Nyílt címzés, illetve láncolással történő nyílt címzés módszere esetén az „várható”, hogy a túlcsordult elemek a túlcsordulás helyéhez viszonylag közel legyenek,
 az elemek tárolásához a ténylegesen szükséges tárhelynél kb. 10%-kal több tárhelyet szokás lefoglalni. Ez tovább növeli a módszerek tárhely igényét.
o Független túlcsordulási lista alkalmazása
 Ennél a módszernél az azonos helyről túlcsordult rekordokat külön listákban, és nem a „folytonos tárban” helyezzük el.
 Ezúttal a mutató oszlopban található értékek egyirányban láncolt listák fejmutatóiként funkcionálnak. (Amúgy hasonlít az előzőre.)
 Az így elkészített táblázatba a nem túlcsorduló elemek kerülnek,
 a szinonim elemek pedig a Hash-függvény által jelzett helyről kiinduló egy irányban láncolt listába kerülnek.
[8]. Ismertesse a lista adatszerkezetekel!
- Szekvenciális adatszerkezetek
o Minden elem két másik elemmel van kapcsolatban, kivéve az első és az utolsó elemet.
- Lista, mint absztrakt adatszerkezet.
o Dinamikus adatszerkezet
o Van első és utolsó eleme - kivéve az üres listát.
o Minden elemnek van rákövetkezője - kivéve az utolsó elemet.
o És minden elemnek van megelőzője - kivéve az első elemet.
o Lista jelölése: Q=[x1,x2, … ,xn], ahol az x-szel jelölt dolgok a lista elemei.
- Az üres listának egy eleme sincs: [ ].
- A lista első elemét szokás a lista fejének is nevezni.
- Azt a listát amelyik úgy keletkezik, hogy az eredeti listából elhagyjuk a fejet (első elemet), a lista farkának hívjuk.
- Fej: [x1]
- Farok: [x2, … ,xn]
- Vége: [xn]
- A lista mérete alatt az elemeinek a számát értjük.
- Méret jelölése: |Q| (=n).
- Alap listaműveletek
o Allista képzés:
 Q[i..j]=[xi,xi+1, … ,xj-1,xj]
 Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
 Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
o Összefűzés (konkatenáció, egyesítés):
 R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
LÉTREHOZÁS
Létrehozákor explicit módon megadjuk a lista elemeit, amelyek a felsorolás sorrendje alapján kapják sorszámaikat.
BŐVÍTÉS
A listát bárhol bővíthetjük. A bővítést részlista képzéssel és konkatenációval realizálhatjuk.
Ha a listát a k-adik elem után akarom bővíteni egy új elemmel, azt úgy tehetem meg: Q[1..k]&[elem] &Q[k+1..n].
CSERE
Allista képzésekkel és konkatenációval realizálható k-adik elem cseréje:
Q[1..k-1]&[x] &Q[k+1..n]
A két részlista közé beillesztjük az új elemet, majd a részeket összefüzzük.
TÖRLÉS
Fizikai törlést jelent. K-adik elem törlése: Két allista képzéssel és az eredményük konkatenálásával tehetjük meg: Q[1..k-1]&Q[k+1..n]
RENDEZÉS
Minden értelmezett, akármelyik használható.
ELÉRÉS
Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi. Az elemek elérése sorszámhivatkozással történik. Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
KERESÉS
Teljes keresés, ill. rendezett listánál lineáris vagy bináris (ez ábrázolás függő is).
FELDOLGOZÁS
Lista elemeit dolgozza fel a speciális lista műveletekkel.
- Speciális listák
o Ezeknél többnyire csak az alábbi hat speciális művelet némelyike használatos.
o Ezek a lista első és utolsó elemének kezelésére szolgálnak.
o ACCES HEAD: Q[1]
o PUSH: Q[x] &Q
o POP: Q[1] és QQ[2..n]
o ACCESS END: Q[n]
o INJECT: QQ &[x]
o EJECT: Q[n] és QQ[1..n-1]
[9]. Ismertesse a Knuth-Morris-Pratt féle mintailleszto algoritmust!
- Szükséges matematikai fogalmak:
o Legyen Ω egy ábécé és x=x1x2…xn, k∈N karakterekből álló sztring, melynek elemei (xi) az Ω ábécé betűi.
o Az x sztringnek u-val jelölt részsztringjét x prefixének nevezzük, ha u=x1…xb, 0<=b<=k.
o Az x sztringnek u-val jelölt részsztringjét x suffixének nevezzük, ha u=xk-b+1…xk, 0<=b<=k.
o Az x-nek egy u prefixet vagy suffixet valódi prefixnek ill. valódi suffixnek nevezzük, ha u≠x, azaz ha b<k.
o Ha b=0, akkor u az üres sztring (u=ε).
o Az r sztringet az x egy borderének nevezzük, ha r megegyezik x egy valódi prefixével és egy valódi suffixével is.
- Példa
o X=abacab
 6 db valódi prefixe van: ε, a, ab, aba, abac, abaca
 6 db valódi suffice van: ε, b, ab, cab, acab, bacab
 Borderek: ε, ab
 Az üres sztring (ε), minden legalább 1 hosszúságú Ω ábécé feletti sztringnek bordere.
 Ugyanakkor ε-nak nincs bordere.
- Az alapsztringben megtartjuk azt a pozíciót, amelyen áll.
- A mintát pedig úgy toljuk arrébb, hogy a pozíciónktól balra továbbra is fennálljon az egyezés. Mekkora legyen a léptetés?
- Megoldás:
o A minta léptetésének mértékét a minta egyező prefixenek a legszélesebb bordere határozza meg. Ebben a példában az egyező prefix hossza 5. Ennek a leghosszabb bordere pedig 3. A léptetés teljes mértéke 5-3=2.
o Előfordulhat, hogy ezután sem lesz egyezés. Ekkor még inkább jobbra kell a mintát csúsztatni. Újabb egyező bordereket keresve. (Újabb léptetések: 3-2=1, ill. 1-0=1.)
- Legyen x egy hosszú sztring. Legyen az x sztringnek r is és s is egy bordere, úgy hogy |r|<|s|.
o x=abacabacaba
o s=abacaba r=aba
o Ekkor belátható, hogy r bordere az s-nek is:
 r prefixe volt x-nek, a hosszuk miatt (|r|<|s|) látható, hogy s-nek is.
 A suffixre ez hasonlóan belátható.
o Ha s a legszélesebb bordere x-nek, akkor az x következő (második legszélesebb) bordere az s legszélesebb bordere lesz.
- A minta egy x prefixének az r bordere, néha bővíthető az a karakterrel úgy, hogy ra bordere xa-nak. (Ha szerencsénk van, a minta a-val folytatódik.)
o abacababadabacabaca
o abacababadabacabaca
o abacababadabacabaca
- Könnyű belátni, hogy amennyiben r a legszélesebb bordere volt x-nek, akkor ra is a legszélesebb bordere lesz xa-nak.
- Az algoritmus előfeldolgozási szakaszában egy m+1 elemű következő névvel ellátott tömböt számítunk ki. A tömb KÖV[i] eleme (i-edik eleme) a minta sztring i hosszúságú prefixéhez tartozó legszélesebb border hossza. i=0,..,m.
- Mivel a 0 hosszúságú üres sztringnek nincs bordere, a KÖV[0]=-1 lesz. (Most 0-val kezdődnek az indexek.)
- m értéke mindig a mintasztring hossza. Például, ha a számítás során már meghatároztuk a KÖV tömb 0-ás indexű elemét, és még néhány további elemét az i.-ig: KÖV[0],…,KÖV[i],
- és most meg szeretnénk határozni a következő elemet: KÖV[i+1].
- Meg kell nézni, hogy a mintának a p1…pi prefixének egy bordere bővíthető-e az előbbi módon a minta következő, pi+1-edik karakterével.
o abacababadabacabaca
o abacababadabacabaca
- A bővítés akkor tehető meg, ha pköv[i]+1=pi+1.
- A bordereket KÖV [i], KÖV[KÖV[i]], … behelyettesítve egyre mélyebben a KÖV értékeket, csökkenő sorrendjükben kell megvizsgálni.
- Ha a border nem bővíthető egy kisebb bordert veszünk veszünk, hátha az bővíthető. Ha az sem, akkor egy mégkisebbet, szűkebbet és így tovább.
-
- KMP előfeldolgozó algoritmus
o Olyan ciklust tartalmaz, amelyben egy j változó rendre felveszi a KÖV tömb eggyel csökkenő indexű értékeit, addig amíg az értéke -1-re nem csökken.
o Egy j szélességű border bővíthető lesz a pi+1-s karakterrel, ha a pj+1=pi+1
o Ha bővíthető volt a border tovább léptetjük a változókat, majd a KÖV tömb aktuális elemének értékül adjuk a j-t (border hosszát).
o Ha nem, a j változónak új értéket adunk.
- A borderek vizsgálata akkor ér véget, ha már nincs bővíthető border (j értéke -1).
- Ha a j változót növeltük, akkor p1…pi+1 prefix legszélesebb bordere j hosszúságú.
- Példa: p=abacababadabacabaca
- Ha eltérést talál az algoritmus a j+1-edik pozíción, a továbbiakban a minta j hosszúságú, illeszkedő prefixének a legszélesebb borderét vizsgáljuk. (Ennek hossza: KÖV[j]). Úgy léptetjük a mintát, hogy ez a border továbbra is illeszkedjen az alapsztring már ellenőrzött részére. A léptetés mértéke: j-KÖV[j]. Ha még mindig eltérés van, a következő bordert vizsgáljuk, addig amíg el nem fogy a border (j=-1), vagy a j+1-edik helyen egyezés van, és a ciklus folytatódhat.
- Ha a minta minden karaktere (m db) illeszkedik az alapsztring megfelelő részére (j=m, 14-dik sor), akkor i-m+1-et adja (az illeszkedés következő indexét).
- Az összehasonlítások során az alapsztringben soha nem vizsgál meg újra a korábban már vizsgált karaktereket (i-t nem csökkenti), szemben a mezítlábas algoritmussal.
- j változó csökkentésének felső korlátja m (a minta hossza)
[10]. Ismertesse a Dömölki-féle SHIFT-AND mintailleszto algoritmust!
- Az algoritmus alapötlete: Legyen p a minta sztringünk, amelynek hossza m. Vegyünk egy m elemű D vektort, amelynek a j-edik eleme 1 értékű, akkor, és csak akkor, ha a minta első j karaktere (p1…pj) szuffixe az alapsztring első i karakterének (a1…ai), egyébként pedig nulla.
- Ha a p minta mérete kisebb mint a számítógép processzorának szóhossza, akkor ez a vektor a processzor egy regiszterében is tárolható. (Ilyenkor a későbbi keresés ezzel gyorsítható.)
- Tegyük fel, hogy az alapsztringet már megvizsgáltuk az i-edik karakteréig, és most olvassuk az i+1-edik karaktert. Ehhez egy új D’-vel jelölt vektort kell meghatározni.
- Megfigyelés: A D’ vektor j+1-edik elemének értéke akkor és csak akkor lesz egy, ha
- egyrészt a D vektor j-edik eleme 1-es volt, vagyis p1…pj szuffixe volt a1…ai-nek,
- másrészt, ai+1=pj+1,azaz a soron következő karaktere megegyezik a minta soron következő karakterével.
- Két része van az algoritmusnak: előfeldolgozás és keresés.
- Előfeldolgozás: Fel kell építeni egy 2 dimenziós B bitmátrixot. Ennek a mátrixnak az oszlopait (m db van belőlük) a minta karaktereivel címkézzük fel, a sorait pedig az ábécé egymástól különböző karaktereivel címkézzük. A sorok címkéi között nem lehet egyforma, de az oszlopoknál igen. A mátrixban egy elem értéke 1-es, ha a sorának és oszlopának az értéke megegyezik, és nulla egyébként.
- További 3 db m elemű segédvektor is kell, amelyeket a következő kezdőértékkel látunk el: D segédvektort kezdetben csupa nulla értékkel töltjük fel. Az U segédvektor legelső eleme 1, a többi 0, és végül a V segédvektor utolsó, azaz m-edik eleme 1 és a többi 0.
- Az algoritmus egy „eltoló” (shift) műveletet is fog még alkalmazni:
- SHIFT(X)=SHIFT(x1,x2,…xm)=(0,x1,…,xm-1).
- Jobbra tolás: balról bejön egy nulla, jobboldalt az utolsó elem eltűnik.
- Algoritmus: a sztringet karakterenként vizsgálja, és minden ai karakterenként a D vektort frissiti a következő formula felhasználásával: D’=(SHIFT(D) ٧U)٨Bai
- Ha a keresés során az i-edik karakter feldolgozásakor teljesül D ٨ V ≠(0,….,0,0,0), akkor megtaláltuk p egy előfordulását a-ban. p első karaktere a i-m+1-edik karakterére illeszkedik.
- V=(0,0,0,…,0,0,1)
- A keresés akkor ér véget, ha a D vektor utolsó pozícióján megjelenik egy 1-es érték.
- A Dömölki algoritmus viszonylag gyors, a bitmátrix egyszer kerül kiszámításra, aztán bitenkénti ÉS illetve VAGY műveletek vannak csak. (Itt az a lényeg, hogy amit mi egy vektorral elvégzendő műveletsornak látunk (Shift, „vagyolás”, „éselés”), az valójában a számítógépnek egy, vagy két változóval történő egyetlen elemi művelet elvégzését jelenti.)
- De még mindig lehet javítani ezen az algoritmuson is.
[11]. Ismertesse a fa adatszerkeztet!
- dinamikus, homogén, hierarchikus adatszerkezet
- Speciális fogalmakat értelmez:
o Gyökér(elem): az az elem a fában, amelynek nincs megelőzője.
o levél elem: az az elem a fában, amelynek nincs rákövetkezője;
o közbenső elem: az összes többi elem, (néha ide tartoznak a levél elemek is)
o él: irányított élek: 2 elem között, „szülő”-től a „gyermek” felé
- út: gráfelméleti út fogalom: fában: 2 elem közötti élsorozat; itt (fa adatszerkezetben) az út is irányított
- szint: a fában: egy adott elem szintje = az adott elem távolsága a gyökértől. A gyökértől az adott elemhez vezető út hossza.
- magasság: a fa szintjeinek a száma, a gyökérelemtől a levélelemekig vezető utak mentén lévő elemek számának a maximuma.
- csúcs, csomópont: az elemek a fában (gráfelméleti fogalom)
- részfa: az eredeti fának egy eleméből (a részfa gyökere) és a belőle elérhető további elemekből (gyermekei, unokái, …) álló része. (Az egész eredeti fa is egy részfa, egyetlen elem (levélelem) is lehet részfa.)
- Rendezetlen fa: az élek sorrendje tetszőleges
- Rendezett fa: Számít az élek sorrendje. Így az előző 2 fa nem ekvivalens. A továbbiakban csak rendezett fákkal foglalkozunk. (A reprezentáció többnyire automatikusan létrehoz egy sorrendet az élek között.)
- Bináris fa: fontos az informatikában. Bármely elemének legfeljebb 2 rákövetkezője van (vagy 0, vagy 1, vagy 2)
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
- Bináris fa:
LÉTREHOZÁS
Üres fát hozunk létre, majd utána bővítjük.
BŐVÍTÉS
Lehet részfával, vagy 1 elemmel. Általában levél elemnél bővítünk (nem mindig, a fa típusától függ)
CSERE
Van, elérés alapján történik.
TÖRLÉS
Részfát vagy 1 elemet. Ekkor a megmaradt elemeket át kell rendezni, hogy továbbra is fa maradjon.
RENDEZÉS
Nincs (illetve bővítés közben előfordulhat)
BEJÁRÁS
Adott adatszerkezet elemeit leképezzük egy sorra. 3 algoritmusa van, preorder, inorder és postorder bejárás.
Preorder: A gyökérelemet a két részfa előtt dolgozzuk fel.
Inorder: A két részfa bejárása között dolgozzuk fel a gyökérelemet.
Postorder: A gyökérelemet a két részfa után dolgozzuk fel.
KERESÉS/ELÉRÉS
A bejárás alapján történik.
- Speciális fa adatszerkezetek
o Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
 Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
o Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
o Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
 Egy lehetséges algoritmus a létrehozására: (tudjuk, hogy összesen n darab elem lesz a fában.)
 Az első elem legyen a gyökérelem.
 Előállítjuk a gyökérnek az nb=[n/2] elemből álló baloldali részfáját ugyanezzel az algoritmussal (rekurzió).
 Majd előállítjuk a gyökérnek az nj=n-1-nb elemből álló jobboldali részfáját ugyanezzel az algoritmussal.
o Keresőfa (rendezőfa): az elemeket kulcsuk alapján rendezzük és kulcs alapján visszakeressük őket.
 Egy fa akkor keresőfa, ha bármely elemére igaz, hogy az adott elem kulcsa
 nagyobb, mint az elem baloldali részfájában lévő kulcsok,
 és kisebb, mint a jobboldali részfájában lévő kulcsok.
 Tehát a keresőfában nem lehet két azonos kulcsú elem.
[12]. Ismertesse az AVL-fa adatszerkezetet és muveleteit!
- Kiegyensúlyozott keresőfa (AVL-fa):
o A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult .
o Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák.
o A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
- AVL fa műveletei:
o Új elem beszúrása az AVL-fába:
 Keresés végrehajtása a fában a keresőfa szabályai szerint. Ha az elem már a fában van: vége (két egyforma elemet nem helyezhetünk el a keresőfában.)
 Ha nincs a fában, levélelemként szúrjuk be a megfelelő helyre és kiegyensúlyozzuk a fát, ha szükséges.
 Ha jobboldalra írunk be, nőhet a jobboldali részfa magassága. Így ugyanolyan magas lesz a két részfa. (Ha egyforma magas lett volna, akkor sem lenne gond, mert eggyel magasabb lenne a jobb, mint a bal a beszúrás után, ami még mindig megfelel a kiegyensúlyozottság feltételeinek.)
 Gond akkor van, ha a magasabb részfába szúrjuk be az újabb elemet és ennek hatására tovább nő a részfa magassága.
 1. eset [LL]: A részfa gyökérelemére nézve elromlik a kiegyensúlyozottság, mivel a különbség 2 lesz a két részfa között.
 2. eset [LR]: a baloldali részfa jobboldali részfájába szúrjuk be az új elemet.
 3. eset [RL]: a baloldali részfa H-2-es és a jobboldali részfa H-s magassága rontja el a kiegyensúlyozottságot.
 4. eset [RR]: a jobboldali részfa jobboldali részfájába szúrúnk be. Az első és a negyedik eset, illetve a második és harmadik eset egymásnak szimmetrikus párjai.
 Első és negyedik eset: külső beszúrás, külső bővítés
 Második és harmadik eset: belső bővítés, belső beszúrás
 Először a külső bővítéssel elrontott fát egyensúlyozzuk ki.
 1. Külső bővítés utáni kiegyensúlyozás
o LL-forgatás (left left)
o (Szimmetrikus párja az RR-forgatás (right right).)
 A részfa új gyökéreleme a régi gyökér baloldali rákövetkezője lesz;
 A régi baloldali rákövetkező jobboldali részfája az új jobboldali rákövetkező (a régi gyökér) baloldali részfája lesz.
 2. Belső bővítés utáni kiegyensúlyozás:
 a belső bővítés után egy forgatással nem lehet megoldani a kiegyensúlyozást
 A belülre beírt új elemet először kihozzuk, de a magasság még mindig nem lesz jó
 LR-forgatás: a baloldali részfa jobboldali részfáját forgatjuk helyre;
 A 3. eset a második esetnek a szimmetrikus párja: a harmadik esetet megoldó két forgatás együttesen RL forgatás (RL= Right + Left).
 A jobboldali részfa baloldali részfájába való beszúrás rontotta el a kiegyensúlyozottságot. Ennek megfelelően zajlik a helyrehozás is.
 Beszúrás után két lépésben minden AVL-fa kiegyensúlyozható.
o Törlés kiegyensúlyozott fából:
 Megkeressük a törlendő elemet, majd töröljük a kereső fából. Ha kiegyensúlyozott maradt a fa, akkor készen vagyunk.
 Ha nem, akkor az előbbi négy eset valamelyike következik be. Ezeket már tudjuk kezelni.
[13]. Ismertesse a piros-fekete tulajdonságokat és a piros-fekete fa egyéb jellemzoit! Adjon meg egy 14 kulcsot és p=2 piros elemet tartalmazó piros-fekete fát! Mely p értékek mellett oldható meg a feladat? (Indokolja is a választ!)
- Piros-fekete fa:
o Olyan bináris kereső fa, melyben minden elemnek színe van, amely vagy piros vagy fekete.
o Az elemek szinezésének szabályozásával biztosítható, hogy benne valamely a gyökértől levélig vezető út hossza nem lehet nagyobb, mint a legrövidebb ilyen út hosszának a kétszerese.
o Ez biztosítja, hogy bármely n db adatelemet tartalmazó piros–fekete fa magassága legfeljebb 2*log2(n+1).
o A piros-fekete fát ezért megközelítőleg kiegyensúlyozottnak tekinthetjük.
- Piros-fekete tulajdonságok:
o Egy kereső fát piros-fekete fának nevezünk, ha teljesülnek rá a következő piros-fekete tulajdonságok:
 Minden elem színe piros vagy fekete
 A gyökérelem színe fekete
 Minden levélelem színe fekete
 Minden piros elemnek mindkét rákövetkezője fekete
 Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.
 (A levélemekben nem tárolunk adatokat.)
BESZÚRÁS ÉS TÖRLÉS
Úgy történik, mint korábban (a piros-fekete fa is kereső fa), de ez megsértheti a piros-fekete tulajdonságokat. Ezért módosítás után lehet, hogy bizonyos elemek színét meg kell változtatni, esetleg forgatással a fa szerkezetét is meg kell változtatni.
BŐVÍTÉS
A piros-fekete fát mint kereső fát bővítjük. Mindig levélelemmel bővíthető. A beszúrt elem színe legyen: fekete, ha ez az első elem (gyökérelem) és piros, egyébként (általában).
Ezt követően meg kell vizsgálni, mely tulajdonságai sérültek a piros-fekete fának?
1. Minden elem színe piros vagy fekete? OK
2. A gyökérelem színe fekete? OK
3. Minden levélelem színe fekete? OK (két fekete NIL kapcsolódik hozzá)
4. Minden piros elemnek mindkét rákövetkezője fekete ? Beszúrt elemnél teljesül, de a szülőjénél sérülhet. (Csak akkor sérül, ha az elem, amihez beszúrtuk az újat, piros színű. Ekkor a fát át kell szervezni.)
5. Bármely két, azonos elemből induló és levélelemig vezető úton ugyanannyi fekete színű elem van.? Teljesül, mert piros elemet szúrtunk be.
TÖRLÉS
Binfából való törléssel megegyező módon (törlendőnek 0, 1, 2 gyermeke van). Ha 2 gyerek van, áttranszformálással jár.
A piros-fekete fa tulajdonságainak helyreállításához a ténylegesen törölt (fizikai-logikai) csomópontot kell figyelembe venni.
[14]. Ismertesse a B-fa adatszerkezetet
- B-fák (Bayer-fák)
o A B-fák lapokból épülnek fel.
o A lapokon mutatók és adatelemek helyezkednek el.
o Az adatelemek a kulcsaik szerint növekvő sorrendben vannak egy lapon.
o A B-fa is kereső fa. Tehát két azonos kulcsú adatelem nincs benne.
o A p-vel jelölt mutatók levéllapokon NIL értékűek, egyébként mindig olyan lapot címeznek, amely a B-fa egy olyan részfájának a gyökereként képzelhető el, ahol minden adatelem kulcsa a mutatót körülvevő adatelemek kulcsai közé esnek:
o További tulajdonságai
 A fának van rendje (n), pl. másodrendű
 Minden lap legfeljebb 2n adatot tartalmazhat
 A gyökérlapot kivéve minden lapon legalább n adat van
 A gyökérlapon lehet ennél kevesebb is (legalább egy elem van ott, ha nem üres a fa)
 Egy lap, vagy levéllap, vagy m+1 rákövetkezője van. m a lapon elhelyezett adatok száma
 Minden levéllap ugyanazon a szinten helyezkedik el.
o Keresés a B-fában
 A keresés minden esetben a gyökérlapon indul (kivéve, ha üres a fa).
 A gyökérlapon végrehajtunk egy lineáris keresést. Ha az elem meg van, KÉSZ.
 Ha nem találtuk meg, a lineáris keresés megáll valahol.
 Ha a lineáris keresés úgy áll meg, hogy a vizsgált elem nagyobb, mint a keresett, akkor az előtte lévő mutató által mutatott lapon folytatjuk tovább a keresést.
 Ha a végére értünk (minden kulcs kisebb volt a keresettnél) és nincs meg, az utolsó mutatóval megyünk tovább.
 Ha utolsó szinten vagyunk és a mutatók értéke NIL és nincs meg az elem, akkor az nincs is a fában.
o B-fa bővítése
 A bővítés is kereséssel kezdődik. Meg kell határozni azt a levéllapot, ahol a bővítendő elemet el tudjuk helyezni.
 B-fát új elemmel mindig csak a levéllapon bővíthetünk.
 Ha a lapon m<2n, akkor a rendezettség megmarad, a lapon elhelyezzük az új elemet.
 Ha a lap tele van (m=2n) ugyan, de az új elemet erre a lapra kellene elhelyezni, a fa szerkezete meg kell, hogy változzon. Az új elemet elhelyezzük a már telített levéllapon. Így itt 2n+1 lesz az elemek száma. Meghatározzuk a középső elemet, ezt kiemeljük a 2n+1 elem közül, és megpróbáljuk a szülő lapján elhelyezni.
 A lap e mentén ketté fog válni:
 a középső elem egy szinttel feljebb vándorol.
 Két levéllapra két mutatót kell a szülőből állítani. A feljebb csúsztatott elem baloldali mutatóját a nála kisebb levéllapra állítjuk, a jobboldalit a nála nagyobb elemeket tartalmazó levéllapra.
 Ha a probléma többször megismétlődik, és felgyűrűzik a gyökérig, a gyökér is kettéválik, egy elem (a középső) eggyel feljebb kerül, azaz új gyökérlap jön létre egyetlen elemmel. Ez az egyetlen eset, hogy a fa magassága növekszik.
o Törlés B-fából
 Ha a törlendő elem levéllapon van. Ekkor fizikailag kitöröljük.
 Ha nem levéllapon van, akkor ezt az adatot helyettesíteni kell egy levéllapbeli elemmel, amely a rendezettséget megtartja. (Pl. jobboldal legbaloldalibb eleme.)
 Mindkét esetben az egyik levéllapon csökken az elemek száma.
 Ha a levéllapon nem csökken n alá az adatok száma: KÉSZ
 Ha n alá csökken, de valamelyik szomszédnál (ugyanebben a részfában) legalább n+1 elem van, akkor a szomszéd laptól elemeket veszünk át a B-fa jelleg megőrzésével. Szokás úgy vágni, hogy az elemek egyenlően oszoljanak meg. Ez a művelet természetesen érinti az előd lapot is.
 Ha a törléssel n alá csökken az elemek száma, és minden szomszédos lapon n elem van, az egyikkel összevonható a törölt elemet tartalmazó lap: (n-1)+n=2n-1. Az elődlapon eggyel kevesebb mutató kell, így eggyel kevesebb elem is: ezt az elemet rárakjuk az összeolvasztott lapra, így 2n db elem lesz a levéllapon. Mivel ilyenkor csökken az előd elemeinek száma, ez felgyűrűződhet a gyökérlapig: a fa magassága ebben az egy esetben csökkenhet.
 A B-fa magassága csak a gyökér felől csökkenhet, illetve nőhet, nem pedig a levéllapok felől.
[15]. Ismertesse a hálós adatszerkezeteket! Külön térjen ki a bejárás stratégiáira!
- Háló
o Bármely elemnek akárhány megelőzője és akárhány rákövetkezője lehet (fa általánosítása). Szélsőséges esetek:
o egy adatelem önmaga megelőzője és rákövetkezője is lehet (f),
o két adatelem kölcsönösen egymás megelőzője és rákövetkezője lehet (b, c).
o irányítatlan gráf esetén …..
o A matematikából ismert, összefüggő irányított gráffal reprezentálható rajzban.
o A gráfok fogalmai, algoritmusai alkalmazhatók.
o Tárolás: szétszórt vagy folytonos
- Háló szétszórt ábrázolása
o Ezt multilistával szokás megvalósítani Mutató tömböket alakítunk ki az elemeknél (az elemeket önkényes módon sorbarendezzük). Ezek a mutatótömbök a megfelelő elemeket címzik.
- Háló folytonos ábrázolása
o Ezt szomszédsági mátrixszal szokás megoldani.
o Boole-mátrix (0,1: logikai értékek)
o Mérete a háló elemeinek számával négyzetesen arányos: nxn-es, ha n elemünk van.
o A mátrix sorait és oszlopait az önkényes sorrend szerint a csúcsok sorszámaival cimkézzük.
- Háló műveletei
LÉTREHOZÁS
Üres adatszerkezetet hozunk létre
BŐVÍTÉS
A szomszédsági mátrixnak eggyel nő a sor és oszlop száma: az új sor és oszlop értékeit a szomszédsági viszonynak megfelelően töltjük fel.
CSERE
Megoldható
TÖRLÉS
A mátrixnak törlődni fog egy azonos címkéjű sora és oszlopa. Az, amelyik a törlendő elemet reprezentálja.
RENDEZÉS
Nem értelmezett
BEJÁRÁS
Egy adott hálós adatszerkezetben kitüntetünk egy elemet, a kezdőpontot, majd ebből kiindulva térképezzük fel a háló összes elemét. A bejárás lehet:
- Szélességi
- Mélységi
KERESÉS
Nem értelmezett
- Háló bejárási stratégiái
o Szélességi bejárás
 A bejárás szisztematikusan vizsgálja az elemeket, az adott elem rákövetkezőit és összegyűjti az S-ből elérhető összes elemet. Létrehoz egy S gyökerű szélességi fát (erdőt), mely ezen elemeket tartalmazza, és benne az S-ből egy adott elemhez vezető út mindig a legrövidebb. Az algoritmus mindig az S-től azonos távolságra levő elemeket vizsgálja, és buborékszerűen terjeszti ki a vizsgálatot eggyel lejjebb lépve.
 A szélességi fa szintenként épül fel, ezért kezdetben minden elem fehér (ezek később szürkékre, majd feketére változnak). Egy elem a bejárás során elértté válik, és szürke színű lesz, ha először jutunk el hozzá. Ezután a színe már nem lehet fehér. A fekete elemek összes megelőzője fekete, rákövetkezőik vagy szürkék, vagy feketék lehetnek. A szürke elemek rákövetkezői fehérek is lehetnek, de a megelőzőjük fekete. A szürke elemek alkotják a buborék felszínét (csak szürke elemről tudunk tovább menni).
 Szürke: elértük a csúcsot. Kiegészítjük vele a fát, amit szintenként építünk.
 Fekete: elértük a csúcsot , plusz az összes rákövetkezőjét is.
 Ha az S-ből az összes elemet megtaláltuk, és még van fehér elem, akkor új kezdőpontot kell választanunk, és újra végre kell hajtanunk rá az algoritmust. Új kezdőpontnak választjuk azt az elemet, pl. amelynek a sorában a legtöbb egyes van.
 A gyakorlatban sok szürke elemet kell kezelnünk, így ezeket az elérésük és feldolgozásuk közötti időre egy sorba jó betenni. A sor első elemével dolgozunk mindig. A fába csak a fehérről szürkére változott elemeket vesszük fel. Egy szélességi fa vagy egy szélességi erdő lett az eredmény
o Mélységi bejárás
 mélységi fa (erdő) építésével S-ből induló utakat próbálunk nyilvántartani.
 Hasonlít a szélességi bejáráshoz, csak a szürke csúcsok feldolgozási idejét változtatjuk meg: amikor választanunk kell a szürke csúcsok közül, mindig az utoljára elért szürke csúcsokból haladunk tovább.
 Egy verembe rakjuk a szürke csúcsokat az elérésük sorrendjében.
 Mélységi erdő lesz az eredmény. Itt abban az értelemben is, hogy a részfák is mélységi fák.
[16]. Műveletek állományokkal, állományok osztályozása
LÉTREHOZÁS
Az állományt valamelyik háttértáron hozom létre. Ki kell választanom a fizikai állomány szervezési módját vagy az állomány tárolási szerkezetét. Az adott szervezési módnak megfelelően kell a logikai rekordokat elhelyeznem a fizikai állományban.
BŐVÍTÉS
Az állomány rekordjainak darabszáma nő, új rekord kerül be az állományba.
CSERE
A rekord bármely mezőjének (kivéve a rekordazonosítónak) értékét cserélhetem valamely más értékre.
TÖRLÉS
Logikai: Az állomány rekordjainak darabszáma nem változik, de a logikailag törölt rekordok meg vannak jelölve, a továbbiakban a feldolgozásban nem vesznek részt. Rendszerfüggő a megvalósítása, a fizikai állományban minden logikai rekordhoz van egy jelző, melynek két állapota van: törölt ill. élő.
- Törlőbájtot alkalmaznak, hogy eldönthető legyen, hogy tényleges rekord-e, vagy már logikailag törölt. Ez plusz 1byte-on tárolható.
- Logikai törlést jelentheti valamelyik mező tartalmának felülírását speciális bitkombinációra.
Fizikai: Az állomány rekordjainak darabszáma csökken, a rekordok nem nyerhetőek vissza. Nehezebb végrehajtani. A kérdés az, hogy a rendszer egyáltalán tud-e ilyet. Általában nem.
ELÉRÉS
Olyan tevékenység, mikor az állomány tetszőleges rekordját akarom megfogni.
- soros elérés: Alapja a rekordok fizikai sorrendje (ahogyan elhelyezkednek a rekordok a háttértáron).
- szekvenciális elérés: Az alapja valamilyen logikai sorrend, az x. rekordot csak az előtt állók elérése után érhetem el.
- közvetlen elérés: Alapja az elsődleges, vagy másodlagos kulcs, bármely rekordot egyből megtalálok, függetlenül a fizikai és logikai sorrendtől. Ilyen elérés csak lemezen lehetséges.
KERESÉS
Soros és szekvenciális elérésnél egy kitüntetett rekordot kell megfognom. A szokásos három módszerrel.
RENDEZÉS
A szokásos (kulcs alapján).
FELDOLGOZÁS
Egy adott állományban lévő információhoz akarok hozzáférni. Egy-egy szerkezetet az minősít, hogy a feldolgozást mennyire segíti. A feldolgozás alapja a szerkezet és az elérés, keresés.
ÚJRASZERVEZÉS
Az állományt a háttértár egy másik területén újra létrehozzuk úgy, hogy közben megváltozik vagy a szerkezete, vagy a tartalma, esetleg mindkettő.
- Állományok osztályozása
o Egyszerű (csak a logikai rekordokat tartalmazza)
 Szeriális
 Szekvenciális
 Direkt
 Random
o Összetett (A logikai rekord adatain túl szerkezethordozó adatok is megjelennek, melyek magáról az állományról adnak információkat és a feldolgozást segítik.)
[17]. A szeriális, szekvenciális, direkt és a random állomány.
- Szeriális állomány
o Nincs szerkezete, a rekordok sorrendje tetszőleges.
o Tetszőleges háttértáron megjelenhet, mindegyik rekordformátumot tudja kezelni, tetszőlegesen lehet blokkolni és szegmentálni.
o Egyszerűen kezelhető.
o Viszonylag gyors, kivéve ha egy adott rekordot keresek, mert a teljes keresés időigényes.
o Minden operációs rendszer, programnyelv stb. tudja kezelni.
o Alapvető szerepet játszik olyan eseteknél, amikor a rekordok véletlenszerűen állnak elő, vagy amikor a véletlenszerűen érkező rekordokat átmenetileg gyűjteni kell, hogy az így létrejövő állományból valamilyen szerkezettel rendelkező állományt hozzunk létre.
LÉTREHOZÁS
A tetszőleges sorrendben jövő rekordok bekerülnek az állományba a beérkezési sorrend szerint.
BŐVÍTÉS
Nincs rendezettség, így a bővítés nagyon egyszerű, az új rekord az állomány végére íródik.
CSERE
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
TÖRLÉS
A lemezen elhelyezett fix rekordformátumú szeriális állomány tudja csak a cserét, a többi esetben csak újraszervezéssel lehetséges.
RENDEZÉS
Nincs.
ELÉRÉS
Csak soros elérésről beszélhetünk, mert csak fizikai sorrend van.
KERESÉS
Teljes keresés.
FELDOLGOZÁS
Az adott fizikai sorrendben végig fel tudom dolgozni az állományt, vagy addig, amíg a feldolgozandó rekordot meg nem találtam (soros elérés). Nem más, mint a rekordok végigolvasása. Viszonylag lassú.
ÚJRASZERVEZÉS
A szerkezetátalakítás miatt ez nem merül fel, mert nincs szerkezet. Akkor van rá szükség, amikor logikailag törölt rekordok fizikai törlését akarom megvalósítani, vagy olyan cserét (nem a fenti esetben), amely engedélyezett.
- Szekvenciális állomány
o A rekordok az azonosító (elsődleges kulcs) szerint rendezettek. Ez egy egyértelmű sorrendet ad, egy adott szerkezetet biztosít.
o Létrehozható mind szalagon, mind lemezen.
o Minden rekordformátumot tud kezelni, a blokkolás is tetszőleges.
o A szakma szűkebb értelemben az azonosító szerinti növekvő sorrendben rendezett állományt nevezi szekvenciálisnak, de a csökkenő sorrendű is kielégíti a fogalmakat.
o Darabolással szintén szekvenciális állományokat kapok. Ez azért lényeges, mert általában kevés a hely, így a résztartományokkal könnyebb dolgozni. Lényeges lehet az állományok mérete a tárkapacitás miatt.
o Előnyei
 Soros és közvetlen elérésű háttértárolón egyaránt létrehozható.
 Jó kapacitáskihasználást tesz lehetővé.
 Szekvenciális módon való feldolgozása egyszerű.
o Hátrányai
 Nem támogatja a közvetlen elérést.
 Aktualizálása újraszervezéssel oldható meg (kivételt képez a közvetlen elérésű háttértárolón elhelyezkedő szekvenciális állományok rekordjainak törlése vagy módosítása).
 Létrehozását rendezés vagy összeválogatás előzi meg.
BŐVÍTÉS
Nem hajtható végre közvetlenül, csak újraszervezéssel.
CSERE
Fix rekordformátum esetén lemezen lehet, bármely más esetben csak újraszervezéssel.
TÖRLÉS
Csak logikai törlést realizál, fizikait csak újraszervezéssel.
ELÉRÉS
A szekvenciális állománynál a logikai és a fizikai sorrend egybeesik, ezért a soros és a szekvenciális elérés ugyanazt jelenti.
KERESÉS
Lineáris keresés, előnyösebb ha több rekordot keresünk egyszerre.
FELDOLGOZÁS
Alapja a keresés. Lineáris keresést használva egyszerre több rekordot is feldolgozhatunk. Ilyenkor elegendő egyszer végigolvasni az állományt, ha a keresés előtt rendezzük a keresendő rekordokat elsődleges kulcsuk szerint.
ÚJRASZERVEZÉS
Általánosan növekvő sorrendű állományból csökkenő sorrendű állományt lehet létrehozni, vagy fordítva. Újraszervezéssel oldható meg a csere, a fizikai törlés és a bővítés. Nem a szerkezetet változtatom.
- Direkt állomány
o A direkt és a random állományok asszociatív szerkezetű állományok.
o Felépítésük és kezelésük a korábban megismert kulcstranszformációs táblázatokéhoz hasonló.
o A rekordok háttértárolón elfoglalt helye egy hash függvény segítségével határozható meg, amely a logikai rekordazonosítóhoz (az elsődleges kulcshoz) rendel egy lemezcímet.
o Amennyiben a hash függvény kölcsönösen egyértelmű, akkor direkt állományról, ha csak egyértelmű, random állományról beszélünk.
o Ha egy logikai adatállományban az elméletileg számba vehető rekordok és ezen keresztül a rekordazonosítók száma közelít az állományban ténylegesen előforduló rekordazonosítók számához, azaz ha az állományt alkotó rekordazonosítók halmazának az eloszlása egyenletes vagy közel egyenletes, akkor célszerűen megvalósítható a kölcsönösen egyértelmű kapcsolatteremtés a logikai rekordok és a fizikai tárolási címek között.
o A nem teljesen egyenletes eloszlású rekordazonosítók esetén azt a gyakorlatot kell követnünk a kölcsönösen egyértelmű megfeleltetés érdekében, hogy az állományban ténylegesen nem létező rekordok számára is helyet foglalunk. Ezzel a megoldással a tárolóterületen felhasználatlan tárolási egységek (címek) alakulnak ki.
o A kölcsönösen egyértelmű hash függvény a logikai rekordazonosítók növekvő sorrendjét létrehozva állítja elő az 1., 2., . . . , n. címeket.
o A hash függvénynek e tulajdonsága teszi lehetővé, hogy a direkt szerkezetű állományokat ne csak közvetlen eléréssel, hanem szekvenciálisan is feldolgozhassuk.
o Fizikailag egyetlen területből (adatterület) épül föl, és csak címezhető háttértárolón hozható létre.
o Az állomány helyigényét egyértelműen meghatározza
o az elméletileg számba vehető rekordazonosítók darabszáma
o a logikai rekordok hossza.
o Csak fix rekordformátumot tud kezelni.
o Az állomány rekordjai nem blokkolhatók és nem szegmentálhatók, azaz egy blokk mérete a logikai rekordmérettel egyezik meg.
o Rendszerek, programnyelvek csak egy része ismeri.
LÉTREHOZÁS
1. Meghatározzuk a hash függvényt, kiszámítjuk a kezelendő rekordok darabszámát, majd kialakítjuk az állomány vázát, azaz előkészítjük a tárolóterületet a rekordok befogadására.
2. A már meglévő váz, vagyis az üres állomány feltöltése tartalommal, azaz a tényleges rekordokkal. A művelet végén maradhatnak üres rekordhelyek (un. alrekordok).
BŐVÍTÉS
Szűkebb értelemben véve bővítésről nem beszélhetünk. Tágabb értelemben véve új rekordokat a leképezési eljárás (hash függvény) által meghatározott címre lehet beilleszteni. Bővítéskor tehát „csak” a helyére kell tenni az újonnan érkező rekordot.
CSERE
Egy rekordban a logikai rekordazonosítón kívül bármelyik adatelem értekét lehet cserélni.
TÖRLÉS
Logikailag törlés létezik
- egy törlőbájttal megjelöljük, hogy az adott rekord már nem élő
- a teljes rekordot (esetleg csak a kulcsot) valamilyen jellel felülírjuk. A törlés következtében feleslegessé váló rekordhelyet más logikai azonosítójú rekord tárolására nem lehet felhasználni.
ELÉRÉS
A rekordok elérése közvetlen
KERESÉS
Nem értelmezett
FELDOLGOZÁS
A rekordok mind szekvenciálisan, mind pedig közvetlen eléréssel feldolgozható. Leggyorsabb feldolgozású állomány. Lehetőségek:
– soros, a rekordok fizikai sorrendjében;
– szekvenciális, ami a hash függvény korábban említett tulajdonságából következően megegyezik a soros feldolgozással;
– közvetlen, a hash függvény segítségével;
– szakaszos szekvenciális, ahol a szakasz első rekordját közvetlenül, a továbbiakat pedig szekvenciálisan érjük el.
ÚJRASZERVEZÉS
Hagyományos értelemben véve nincsen szükség rá, mert az állomány létrehozásakor az elméleti rekordszámnak megfelelő helyet foglaljuk le. Felmerülhet viszont az újraszervezés igénye akkor, ha változik, azaz bővül vagy szűkül az elméletileg számba vehető logikai rekordazonosítók tartománya.
- Random állomány
o A csak egyértelmű (de nem kölcsönösen egyértelmű) hash függvény miatt előfordul, hogy a különböző azonosítójú rekordok ugyanarra a címre képződnek le.
o A random szerkezetű állományok túlcsordult rekordjainak elhelyezéséről és kezeléséről külön technika segítségével kell gondoskodnunk (szinonimakezelés).
o A túlcsordult rekordok elhelyezésére alapvetően kétféle lehetőség kínálkozik
o az elsődleges adatterületen
o független túlcsordulási területen.
o A random állomány mindhárom rekordformátumot (fix, változó és határozatlan) tudja kezelni.
o A rekordokat általában nem blokkoljuk.
[18]. Összetett állománykezelési technikák (láncolás, indexelés).
- Alkalmazásának célja: a feldolgozás gyorsítása, kényelmesebbé tétele.
- Alapját egy egyszerű szerkezetű állomány, az alapállomány képezi, amely legtöbbször szeriális vagy szekvenciális. Az alapállományra épülnek rá a plusz információhordozó adatok.
- Alapvetően két technikát különböztetünk meg:
o láncolás esetén az információhordozó adatok az állományon belül jelennek meg mutatómezők formájában, ekkor a rekordokat láncolt listába fűzzük föl;
o indexelés eseten a plusz információk az állományon kívül, általában egy (vagy több) indextábla formájában jelennek meg.
- Mivel mind a két technika lemezcímeket kezel, ezért az összetett állományszerkezetek csak közvetlen elérésű háttértárolón alakíthatók ki.
-
- Indexelési technikák
o Alapja: rekordok elsődleges vagy másodlagos kulcsa
o Elsődleges kulcs
 Indextábla kulcs oszlopban a rekordok elsődleges kulcsértékei növekvő sorrendben, érték oszlopban pedig a megfelelő rekordok lemezcímei Általában kis méretű, ezért elfér a memóriában (bináris keresés alkalmazható), ha mégsem, akkor szekvenciális állományként jelenik meg a háttértáron.
 Elsődleges kulcsra épülő, egyszintű, teljes indexelés
 Nem teljes (részleges) indexelés Az indextáblában csak a részhalmazok első elemeit tüntetjük fel ( kisebb indextábla) részhalmaz behatárolása után annak kezdőcímétől kiindulva lineáris kereséssel folytatjuk a keresést az alapállományban (ehhez szekvenciálisnak kell lennie).
 Többszintű indexelésnek Nagyméretű állományok esetén célszerű lehet magát az indextáblát is indexelni, mely igény szerint ismét indexelhető, …
o Másodlagos kulcs
 Az indextábla kulcs oszlopába a rekordokban szereplő különböző másodlagoskulcs-értékeket írjuk, tehát a táblának annyi sora lesz, ahány különböző másodlagoskulcs-érték szerepel az alapállományban. Az egyes kulcsértékek mellé az érték oszlopba több lemezcím is kerülhet, azoké a rekordoké, amelyekben megtalálható az adott másodlagoskulcs-érték. Az indexelés lehet többszintű, ekkor azonban az első szinten csak teljes indexelésnek van értelme.
[19]. Indexelt szeriális és szekvenciális állomány!
Indexelt szeriális állomány:
Ahhoz, hogy egy kulcs szerinti rendezetlen adatállományban biztosítani lehessen az egyes rekordok közvetlen elérhetőséget, kapcsolatot kell teremteni a rekordazonosítók és a tarolási címek között. Ha ez a szükséges kapcsolatteremtés a rekordazonosítók és a tarolási címek között az indexelési technika segítségével valósul meg, akkor indexelt szeriális állományszerkezetet kapunk. Az indexelt szeriális állományszerkezet két fő részből tevődik össze:
- egy szeriális alapállományból és
- a szeriális alapállomány logikai rekordjainak azonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szeriális állományt. Az alapállomány logikai rekordjainak az indexelése csak teljes lehet, többszintű indexeléskor viszont a magasabb szinten levő indexek – értelemszerűen – nem teljes indexek lesznek.
Indexelt szekvenciális állomány:
Egy indexelt szekvenciális állomány nem más, mint egy olyan, indexszerkezettel kibővített szekvenciális állomány, mely lehetővé teszi a közvetlen elérésen alapuló feldolgozást es karbantartást is. Az indexelt szekvenciális állomány abban hasonlít a szekvenciális állományhoz, hogy szekvenciálisan is feldolgozható, mivel a benne elhelyezkedő rekordok azonosító szerint szekvenciálisan rendezettek. Ez a szekvenciális sorrend kezdetben (lásd létrehozás) azonos a fizikai sorrenddel, később (lásd bővítés) a kettő bizonyos mértékig elválik. Az indexelt szekvenciális állomány abban hasonlít a random (direkt) állományhoz, hogy az állomány logikai rekordjai közvetlenül elérhetők, ami egy szekvenciális állomány eseten nem lehetséges. Az alapvető különbség az indexelt szekvenciális és a random (direkt) állományszerkezet között az, hogy míg a random (direkt) állománynál a közvetlen hozzáférést az azonosítóból egy algoritmussal képzett cím alapján biztosítjuk, addig az indexelt szekvenciális állományoknál a közvetlen hozzáférést az elkülönítetten kezelt es tarolt indextábla(k)ban elhelyezett azonosító és cím közötti kapcsolat teszi lehetővé. Az indexelt szekvenciális állományszerkezet tehát két fő részből tevődik össze:
• egy (létrehozáskor) szekvenciális szerkezetű alapállományból és
• a szekvenciális alapállomány logikai rekordazonosítóira felépített indexstruktúrából.
A két összetevő együttesen alkotja magát az indexelt szekvenciális állományt. Egy indexelt szekvenciális állomány csak közvetlen elérésű (címezhető) háttér- tárolón hozható létre. A rekordokat a szekvenciális alapállományban taroljuk, az egyes logikai rekordokat a rekordazonosítóval különböztetjük meg. Az indexstruktúra segítségével biztosítható az állomány egyes elemeihez való közvetlen hozzáférés.
[20]. Invertált állományok!
Egy egyszerű alapállomány mellé felépül a másodlagos kulcsra egy teljes indextábla. Az 1. oszlopban vannak a másodlagos kulcsértékek. Annyi sora van ahány különböző másodlagos kulcsérték előfordul az alapállományban. A táblázatban szereplő minden másodlagos kulcsértékhez egy teljes indextáblát rendelünk, melyben benne szerepel minden olyan rekord, mely rendelkezik az adott másodlagos kulcsértékkel.
Olyan állomány, amely nem kulcs mezőre tartalmaz indexeket. Az index neve ekkor másodlagos index. invertált állomány mutatói:
- fizikai
o közvetlenül a blokkra mutat
o sűrű index
- logikai
o az adatállomány valamelyik kulcsának értékét tartalmazza
KIS KÉRDÉSEK
[1]. Ismertesse a bináris fákkal kapcsolatban a „kiegyensúlyozott”, „tökéletesen kiegyensúlyozott”,„szigorúan bináris” és a „minimális magasságú” fogalmakat!
- Minimális magasságú fa: akkor ilyen egy fa, ha az aktuális számú elem nem lenne elhelyezhető egy kisebb magasságú fában.
- Egy lehetséges megvalósítás, ha a levélelemek mindegyike a legalsó két szinten található és a legalsó szint kivételével minden szintre a lehető legtöbb elemet tesszük. Ahogy jönnek az új elemek egyenletesen osztjuk meg őket a bal és a jobb oldalon.
- Kiegyensúlyozott fa: ha minden elem esetén a bal és jobboldali részfáknak a magasságkülönbsége legfeljebb 1.
- Tökéletesen kiegyensúlyozott fa: ha a fa bármely elemének bal és jobboldali részfájában az elemek száma legfeljebb eggyel tér el.
- Szigorú értelemben vett bináris fa: a fa bármely elemének vagy 0, vagy 2 rákövetkezője van.
[2]. Mire kell kiemelt figyelmet fordítani a táblázat adatszerkezet esetén a beszúrás és a csereműveletek megvalósítása során?
Mire kell figyelni táblázat adatszerkezet esetén a beszúrás és csere műveletek megvalósítása esetén
- Beszúrás
o A kulcsrészbe csak egyedi értékek kerülhetnek (egy táblázatban nem megengedhető két azonos kulcsérték).
o A kulcs és az elem típusa egymástól különbözhet
o Viszont minden kulcs, és minden elem azonos típusú, és így a táblázat homogén adatszerkezet.
- Csere: A csere művelete megengedett: az adatrészt bármikor cserélhetjük, a kulcsot viszont csak akkor, ha az új kulcs még nincs a táblázatban.
[3]. Ismertesse röviden a speciális halmaz műveleteket!
- ELEME (∈, in ): megmondja, hogy egy adott adatelem benne van-e a halmazban, vagy sem
- UNIÓ KÉPZÉS ( U, + ): eredménye egy olyan új halmaz, amelynek elemei a kiinduló halamazok valamelyikében szerepeltek (elemei voltak).
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- METSZET KÉPZÉS (∩, * ): eredménye egy olyan új halmaz, melynek elemei a kiinduló halmazokmindegyikében szerepeltek.
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- KÜLÖNBSÉGKÉPZÉS ( \, - ): eredménye egy olyan új halmaz, amelynek elemei a műveleti jel bal oldalán álló halmazban szerepeltek, a jobb oldalán halmazban pedig nem szerepeltek.
o Visszavezethető logikai műveletekre.
- KOMPLEMENTER KÉPZÉS: (alaphalmaz)
o Visszavezethető a logikai NEGÁLÁS műveletére.
- Összehasonlítás:
o Egyenlőség
o Valódi és „nem valódi” részhalmaz
[4]. Jellemezze röviden az önátrendező táblázat adatszerkezetet!
- A soros táblázat hátrányos tulajdonságát próbálja meg kiküszöbölni az önátrendező táblázat.
- Az önátrendező táblázatban az elemek keresési gyakoriságuk fordított sorrendjében helyezkednek el.
- Ez lenne a jó. Csakhogy az ilyenfajta sorba állításhoz ismerni kellene az elemek feldolgozási gyakoriságát. De nem ismerjük.
- Viszont a önátrendező táblázat segítségével ez a sorrend nagyon jól közelíthető:
o a táblázatot az elemek feldolgozásakor folyamatosan átrendezzük:
o ha egy elemre hivatkozás történik (fel akarjuk dolgozni), akkor azt a feldolgozást követően a táblázat elejére csúsztatjuk.
- A többi elem egymáshoz viszonyított sorrendje változatlan marad.
- Az utoljára feldolgozott elem a táblázat elejére kerül.
- Sok feldolgozási lépés után nagy átlagban a nagyobb visszakeresési gyakorisággal rendelkező elemek a táblázat elején lesznek megtalálhatóak.
- Ábrázolása egyértelműen a szétszórt ábrázolással praktikus.
[5]. Ismertesse röviden a verem adatszerkezetet!
- Egy speciális lista adatszerkezet. Az előbbi műveletek közül az
o ACCES HEAD
o PUSH
o POP műveleteket lehet értelmezni rajta.
- A verem alján van a legkisebb sorszámú elem, feljebb egyre nagyobb sorszámúak. A vermet LIFO (last in first out) adatszerkezetnek is szokás nevezni.
- Az utolsónak érkezett fog először távozni.
LÉTREHOZÁS
Mindig az üres vermet hozzuk létre.
BŐVÍTÉS
A Push művelet alkalmazásával.
CSERE
Nincs
TÖRLÉS
Csak fizikai, csak a legutolsó elemet lehet.
RENDEZÉS
Nem értelmezett
ELÉRÉS
Csak a legutoljára elhelyezett elemet lehet
KERESÉS
Nem értelmezett
[6]. Milyen kapcsolat van az elemek száma és a fa magassága között a) kiegyensúlyozott fa, b) piros-fekete fa esetén? Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan (c), ill. maximálisan (d)?
magasság: m Minimum elemszám : m Maximum elemszám : (2^m)-1
Piros fekete fa: Elemszám: n Maximum magasság: 2*log2(n+1) Minimum magasság: log(2n+1) Megjegyzés: A Fekete magasság lehet kisebb mint a minimum magasság, mert a fa piros elemeket is tartalmaz
Hány eleme lehet egy 5 mélységű kiegyensúlyozott fának minimálisan : 5 maximálisan: 2^5-1 =31
[7]. Milyen kapcsolat van az elemek száma és a fa magassága között a) szigorúan bináris fa és b) tökéletesen kiegyensúlyozott fa esetén? Hány eleme lehet minimálisan (c) ill. maximálisan (d) egy 7 magasságú szigorúan bináris fának?
Szigorúan bináris fa magasság: m minimum elemszám: 2^(m-1)+2 maximum elemszám: (2^m)-1 Tökéletesen kiegyensúlyozott fa: magasság: m minimum elemszám: 2^(m-1)+1 maximum elemszám: (2^m)-1 Hány eleme lehet egy 7 magasságú szigorúan bináris fának? minimálisan: 2^(7-1)+2 =66 maximálisan: 2^7-1= 127
[8]. Ismertesse röviden a háromszögmátrixok tárolási módját!
- A felső háromszögmátrix elemeit oszlopfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j>=r, akkor: j(j-1)/2+r
- j(j-1)/2: a j. oszlop előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- r: a j. oszlopban ennyi elemet képezünk le.
- Ha j<r, akkor: ?
- Az alsó háromszögmátrix elemeit sorfolytonosan bejárva egyesével, egymást követően helyezzük el egy V tömbbe. Ennek elemei száma: n(n+1)/2.
- Ebből a tömbből hogyan tudjuk ezt az információt visszanyerni? Hányadik eleme lesz a vektornak az eredeti háromszögmátrixban az r. sorban és j. oszlopban elhelyezkedő elem?
- Ha j<=r, akkor: r(r-1)/2+j
- r(r-1)/2: az r. sor előtt a mátrixban ennyi értékes elemet képeztünk már le a vektorba.
- j: az r. sorban ennyi elemet képezünk le.
- Ha j>r, akkor: ?
[9]. Jellemezze röviden a sztring adatszerkezetet!
- Ez egy szekvenciális adatszerkezet.
- Olyan lista, amelynek elemeit egy ABC szimbólumai alkotják.
- Olyan sztringekkel fogunk foglalkozni, melyek elemei karakterek lesznek.
- A sztringeken értelmezhetők a lista alapműveletei
- Bármely karakter elérése
- Részsztring képzés
- Konkatenáció (összefűzés)
- Sztringek lényeges jellemzője a hosszuk
- Feldolgozásuk során fontos az üres sztring fogalma
LÉTREHOZÁS
Megadjuk (felsoroljuk) a sztring összes karakterét
BŐVÍTÉS
Elején, végén, bármely két karakter között részsztring beillesztésével, majd konkatenálásával
TÖRLÉS
Részsztringet lehet törölni
CSERE
Részsztringet részsztringgel
KERESÉS
Részsztring keresése (mintaillesztéssel)
[10]. Milyen különböző folytonos ábrázolási módjai vannak a sztring adatszerkezeteknek?
- Minden sztringet azonos hosszú tárterületen tárolunk. Ha szükséges, a ki nem használt tárterületeket speciális karakterrel töltve fel.
- Változó hosszon, minden sztring előtt megadva annak hosszát. A lefoglalt tárhelyek közül egy szám információ lesz az első.
- Folyamatos tárolásnál a sztringek végén speciális karaktert (végjel) alkalmazunk.
- Folyamatosan, hosszúságinformáció és végjelek nélkül. Kiegészítésként használunk egy nyilvántartást a sztringek kezdőcímével és hosszával.
[11]. Milyen előnye/hátránya van sztringek esetén a szétszórt ábrázolásnak?i
- A listafejben található, a sztringre vonatkozó hossz információ és
- Az alábbi technikák lehetségesek
o Egy-egy karakter egy listaelem (rossz helykihasználás, a mutató nagyobb tárhelyet használ, mint a karakter).
o Változó hosszúságú listaelemekkel. Egy-egy listaelem ilyenkor több karaktert tartalmaz (részsztringek). Ekkor a listafejben a részsztringek hosszáról is szükséges információ.
o Nehéz nagy részsztringeket kezelni, ezért inkább folytonosan szokták ábrázolni.
[12]. Jellemezzen röviden három mintaillesztő algoritmust!
- Brute Force mintaillesztés
o Mezítlábas, hétköznapi algoritmusok. Nem nagyon hatékonyak.
o Összehasonlítja az alapsztring első karakterét a minta első karakterével
o Ha egyezést talál, mindkét sztringben tovább lép és azokat hasonlítja össze (második karaktert a második karakterrel).
o addig, amíg el nem érte és össze nem hasonlította a P utolsó karakterét is, vagy pedig valahol eltérést nem talál.
o Ha P-t végig összehasonlította és egyezést tallt, akkor P benne volt az alapsztringben.
- Sok sztringkezelő algoritmus létezik még. (KMP, SHIFT-AND, SHIFT-OR)
- Olyanok is vannak, amelyek összetett mintákát is tudnak illeszteni. Pl. „ab*c?d(.e)+f” *: tetszőleges számú (0 vagy több) előfordulás, +: 1 vagy több előfordulás, ?: 0 vagy 1 előfordulás, .: tetszőleges karakter
- Így a fenti minta illeszkedik az alábbi alapsztringekre: „fgabbbdreefad”, „rtacdhejefr”, „sabbbcdeenefh”, „addef”
- de nem illeszkedik az alábbiakra: „abbckld”, „acdbf”, „cvfdcd”
[13]. Ismertesse röviden a karakterisztikus függvényeket! (Halmaz adatszerkezet)
- A halmaz ábrázolása karakterisztikus függvénnyel történik, amelyet általában folytonos módon ábrázolunk a következő módon:
o Adunk egy felső korlátot a lehetséges elemek számára. (Megadjuk az „alaphalmaz” számosságát.) (Itt használjuk ki, hogy nem engedtük meg a végtelen számosságú halmazok létét.)
o Lefoglalunk annyi bitet, ahány eleme lehet a halmaznak.
o A lehetséges elemeket „sorba állítjuk”.
o Az elemekhez a sorrend alapján kölcsönösen egyértelműen hozzárendelünk egy-egy bitet a lefoglaltak közül.
o A továbbiakban ezen bit 1-es értéke jelzi ha az adott elem eleme a halmaznak, és a bit 0-s értéke jelzi, ha nem eleme a halmaznak.
- Két, karakterisztikus függvénnyel ábrázolt halmaz közötti összes elemi halmazművelet az előbb megadott bitvektorok közötti logikai műveletekre vezethető vissza. (A számítógépek nagyon „erősek” a logikai műveletek körében.)
- Az eleme művelet:
o létrehozunk egy olyan bitmintát, ahol az „ellenőrizni kívánt” elemhez tartozó bitet 1-re, a többit 0-ra állítjuk, majd
o e között és a karakterisztikus függvény bitvektora között végrehajtunk egy „bitenkénti logikai ÉS” műveletet.
o Ha eredményül nem a csupa 0 bitet tartalmazó bitvektort kapjuk, akkor a kérdéses elem eleme a halmaznak.
o Egyébként nem.
- Az unió képzés művelete:
o Visszavezethető a logikai VAGY műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai VAGY műveletet.
o Eredményként a két kiinduló halmaz uniójának karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A metszet képzés művelete:
o Visszavezethető a logikai ÉS műveletre.
o Tekintsük a két halmazt leíró karakterisztikus függvények bitvektorát.
o Hajtsuk végre a két bitvektor közötti (bitenkénti) logikai ÉS műveletet.
o Eredményként a két kiinduló halmaz metszetének karakterisztikus függvényéhez tartozó bitvektort kapjuk.
- A komplementer képzés művelete:
o Visszavezethető a logikai NEGÁLÁS műveletére.
- A különbség képzés művelete:
o Visszavezethető logikai műveletekre.
[14]. Jellemezze röviden az AVL-fa adatszerkezetet!
A tökéletesen kiegyensúlyozott keresőfában a beszúrás és a törlés végrehajtása után a tökéletes kiegyensúlyozottság visszaállítása nagyon bonyolult. Az AVL-fában ugyanezek a műveletek egyszerűbben végrehajthatóak. Ez az oka, hogy az AVL-fákat elterjedten alkalmazzák. A kiegyensúlyozott fa magassága elemszámtól függetlenül legfeljebb 45%-kal nagyobb, mint a tökéletesen kiegyensúlyozott fáé.
[15]. Ismertesse röviden a rekord adatszerkezetet!
- A rekord statikus adatszerkezet, heterogén (ez az egyetlen).
- Mezőkből áll, ezek sorrendje kötött, mindegyiknek saját neve van.
- Tárolása: folytonos, de szétszórt is lehet
- Az érték lehet:
o Atomi
o Rekord
LÉTREHOZÁS
Mezők neve alapján, nem minden mező kap szükségszerűen értéket.
BŐVÍTÉS
Nincs. Több mező nem lehet, de értéket kaphat olyan mező, aminek eddig még nem volt értéke.
FELDOLGOZÁS
Mezőnevek alapján
BEJÁRÁS
Nincs
TÖRLÉS
Csak logikai (cserével valósul meg)
CSERE
Név alapján az értéket cseréljük
RENDEZÉS
Nincs
ELÉRÉS
Közvetlen, mező név alapján (a rekordon belül)
KERESÉS
Nincs
[16]. Milyen feltételeknek kell teljesülniük egy adatszerkezetre, illetve annak reprezentációjára, hogy használható legyen a bináris keresés?
- Az adatszerkezet rendezett legyen
- Folytonos tárolású legyen
[17]. Ismertesse a röviden a kupac adatszerkezetet!
- A kupac gráfja:
o A minden szintje teljesen kitöltött, kivéve a legalacsonyabb szintet,
o ahol balról jobbra haladva csak egy adott csúcsig vannak eleme
o Azaz, egyértelmű kapcsolat van a kupac elemszáma, és az őt ábrázoló fa gráfja között
- A “kupac-tulajdonság” (maximum kupac esetén)
o A kupac minden i gyökértől különböző elemére teljesül, hogy: Szülő( i ).adat ≥ i.adat
o Azaz, egy részfa legnagyobb értékű eleme mindig a részfa gyökerében található.
LÉTREHOZÁS
Létrehozhatunk üres kupacot, vagy építhetünk kupacot előre megadott elemekből .
BŐVÍTÉS
Új elem elhelyezése a kupacban (tulajdonságok megőrzésével)
FELDOLGOZÁS
Tipikusan a gyökérelemre korlátozódik, és tipikusan törléssel folytatódik
BEJÁRÁS
Az ábrázolás módjától függően -- alapvetően szekvenciális
TÖRLÉS
Gyökérelemet törlünk (és átszervezés, a tulajdonságok megőrzéséért)
CSERE
Általában csak valamely elem értékének növelése támogatott (Elsőbbségi sorként való alkalmazás estén.)
RENDEZÉS
Csak a kupac-tulajdonság erejéig
ELÉRÉS
Szekvenciális
KERESÉS
Nem szokásos
[18]. Ismertesse röviden a lista adatszerkezet alap műveleteit!
- Hozzáférés (elérés):
o Minden elem a többitől függetlenül, közvetlenül elérhető. Q[i]=xi.
o Az elemek elérése sorszámhivatkozással történik.
o Ha nem létező sorszámra hivatkozunk, akkor a hozzáférés az üres listát adja.
- Allista képzés:
o Q[i..j]=[xi,xi+1, … ,xj-1,xj]
o Az eredeti listának két megadott sorszámú eleme közötti részlistát adja eredményül.
o Ha az i sorszám értéke<1, akkor az allistaképzés az első elemtől indul, ha a j értéke >n, akkor az n-edik elmig tart.
- Összefűzés (konkatenáció, egyesítés):
o R=[y1,y2, … ,ym]  Q&R=[x1,x2, … ,xn, y1,y2, … ,ym]
[19]. Jellemezze röviden a sor adatszerkezetet!
- A sor adatszerkezet olyan speciális lista, amelyet a műveletei definiálnak.
o 1. ACCESS HEAD
o 3. POP itt GET-nek nevezzük
o 5. INJECT itt PUT-nak nevezzük
- Kiegészítésként kiemeljük az első és az utolsó elemet
- FIFO adatszerkezetnek is nevezik (First In First Out)
- Ennek megfelelően a sorba az elemek az érkezésnek megfelelő sorrendben kerülnek, az újak mindig a sor végére kerülnek
- Feldolgozni a sor első elemét szokás, ami egyben fizikai törlést is jelent
ÍRÁS
PUT művelet segítségével
BŐVÍTÉS
Az utolsó mutató után a mutatók átállításával
FELDOLGOZÁS
A fejmutató által hivatkozott elemet
FIZIKAI TÖRLÉS
Olvasással (GET művelet) ami egyben fizikai törlést jelent
LOGIKAI TÖRLÉS
Nincs
RENDEZÉS
Nincs értelmezve
ELÉRÉS
Csak az első elemet tudjuk elérni
KERESÉS
Nincs értelmezve
- Sorok fajtái:
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Speciális sorok:
o Kétvégű sor
o Prioritásos sor
[20]. Jellemezze röviden a sor adatszerkezet folytonos ábrázolásait!
- Folytonos ábrázolás:
- Folytonos reprezentációk mindegyike egy vektorban tárolja a sor elemeit
- Fontos a sor elejének és végének jelzése
o Fix kezdetű sor
o Vándorló sor
o Ciklikus sor
- Fix kezdetű sor
o A sor első eleme a vektor első tárhelyén helyezkedik el, az utolsó elem mutatója v.
o Üres a sor: v=0
o Tele van a sor: v=n
o Új elem beírása: v+1-edik helyre kerül, majd v eggyel megnő.
o Elem törlése: Nehézkes, sok adatmozgatással jár. A sor első elemét dolgozzuk fel, a sor eleje pedig mindig ugyanott kell, hogy legyen, ezért törlés után a többi elemet rámozgatjuk az előző pozícióra. v értéke pedig eggyel csökken.
- Vándorló sor
o A sokszori adatmozgatást küszöböli ki
o Elvetjük azt a megszorítást, hogy az első elem az első helyen álljon. Megengedjük, hogy az első elem helye vándoroljon.
o Ehhez segédmutatók, e és a szokásos v szükséges
o Üres a sor: e=v=0
o Tele a sor: e=1, v=n
o Új elem bekerülése: A v mutatót követő pozícióra kerül be, ha a sor nincsen tele.
o Bővítéskor (PUT-nál) előfordulhat, hogy a v az utolsón áll, de az e vándorlása miatt a sor nincs tele: ilyenkor (csak ilyenkor), adatmozgatást hajtunk végre: A legelső pozícióig toljuk a sort előre.
- Ciklikus sor:
o Az adatmozgatást eddig még nem küszöböltük ki teljesen. A ciklikus sorban az elejét és végét jelző mutató vándorlását a határokon keresztül is megengedjük.
o Üres a sor: e=v=0
o Tele a sor: e=1 és v=n, vagy e = v+1.
o Új elem: szabályokat figyelembe véve, ha a sor nincs tele, akkor a v+1-edik helyre kerül, (esetleg v visszaugrik az elejére).
o Törlés: e mutató által mutatott elem, majd e=e+1.
[21]. Milyen előnye/hátránya van sorok esetén a szétszórt ábrázolásnak?
- Szétszórt ábrázolás:
o egyirányban láncolt listával,
o két segédmutatóval (fej és vége mutató)
o Feldolgozás a fejmutató által hivatkozott elemet
o Bővítés: az utolsó mutató után a mutatók átállításával

EGYSZERŰ GYAKORLAT ORIENTÁLT FELADATOK
Hány atomi adatot kell tárolni egy 1300x1200 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 11000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 11000 ritka elem van 11000 adattárolás oszlop: 11000 ritka elem van 11000 adattárolás érték: 11000 ritka elem van 11000 adattárolás S: ahány sorszám van,itt 1300 O: ahány oszlopszám van 1200 Következő: +11000 adattárolás összadat: 3*11000+1300+1200
Adjon algoritmust az egy irányban láncolt lista végén történő bővítésre!
procedure BESZÚR_VÉGE_REK(listafej, érték)
-- új elem beszúrása a lista végére rekurzívan
1. if listafej = NIL then
2. listafej ← lefoglal
3. listafej–>adat ← érték
4. listafej–>következő ← NIL
5. else
6. BESZÚR_VÉGE_REK(listafej–>következő, érték)
7. end if
end procedure
VAGY
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. új–>következő ← NIL
4. if listafej = NIL then
5. listafej ← új
6. else
7. x ← listafej
8. while x–>következő ≠ NIL do
9. x ← x–>következő
10. end while
11. x–>következő ← új
12. end if
end procedure
Adjon algoritmust a rendezett egy irányban láncolt lista –rendezettségét megőrző- bővítésre!
procedure BESZÚR_RENDEZVE(listafej, érték)
-- új elem beszúrása egy rendezett listába iteratívan
1. új ← lefoglal
2. új–>adat ← érték
3. x ← listafej
4. előző ← NIL
5. while x ≠ NIL és x–>adat < érték do
6. előző ← x
7. x ← x–>következő
8. end while
9. új–>következő ← x
10. if előző = NIL then
11. listafej ← új
12. else
13. előző–>következő ← új
14. end if
end procedure
VAGY
procedure BESZÚR_RENDEZVE_REK(listafej, érték)
-- új elem beszúrása egy rendezett listába rekurzívan
1. if listafej = NIL vagy listafej–>adat  érték then
2. új ← lefoglal
3. új–>adat ← érték
4. új–>következő ← listafej
5. listafej ← új
6. else
7. BESZÚR_RENDEZVE_REK(listafej–>következő, érték)
8. end if
end procedure
Adjon algoritmust a két irányban láncolt lista elején történő bővítésre!
procedure BESZÚR_ELEJE(listafejek, érték)
- - új elem beszúrása a lista elejére
1. új ← lefoglal
2. új→adat ← érték
3. új→elozo ← NIL
4. új→következo ← listafejek.elso
5. listafejek.elso ← új
6. if listafejek.utolsó = NIL then
7. listafejek.utolsó ← új
8. else
9. új→következo→elozo ← új
10. end if
end procedure
Adjon algoritmust a cirkuláris láncolt lista végén történő bővítésre!
procedure BESZÚR_ELEJE(listafej, érték)
-- új elem beszúrása a lista elejére
1. új ← lefoglal
2. új–>adat ← érték
3. if listafej = NIL then
4. új–>következő ← új
5. else
6. x ← listafej
7. while x–>következő ≠ listafej do
8. x ← x–>következő
9. end while
10. x–>következő ← új
11. új–>következő ← listafej
12. end if
13. listafej ← új
end procedure
Adjon algoritmust a cirkuláris láncolt lista elején történő bővítésre!
procedure BESZÚR_VÉGE(listafej, érték)
-- új elem beszúrása a lista végére
13. új ← lefoglal
14. új–>adat ← érték
15. if listafej = NIL then
16. listafej ← új–>következő ← új
17. else
18. x ← listafej
19. while x–>következő ≠ listafej do
20. x ← x–>következő
21. end while
22. x–>következő ← új
23. új–>következő ← listafej
24. end if
end procedure
Az M 30x40-es mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M11,20-et? A mátrix melyik eleme található a vektor 143. indexű helyén? Válaszoljon a kérdésekre sorfolytonos és oszlop folytonos tárolás mellett!
Sorfolytonos: (11-1) * 40 + 20 = 420
Oszlop folytonos: (20-1)*30+11=581 a 143-ik elem meg a M11,13 pontba található.
Az M felső háromszög-mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M13,22-et? A mátrix melyik eleme található a vektor 147. indexű helyén?
Az M szimmetrikus mátrixot a V vektorban tároljuk. A vektor melyik eleme tárolja M17,14-et? A mátrix melyik elemei találhatóak a vektor 141. indexű helyén?
Hány atomi adatot kell tárolni egy 2200x2000 méretű ritka mátrix 4+2 soros reprezentációjában, ha a mátrixnak 8000 nullától különböző eleme van? Mennyit kellene tárolni „hagyományos” tömb-reprezentáció esetén?
Sor: 8000 ritka elem van 8000 adattárolás oszlop: 8000 ritka elem van 8000 adattárolás érték: 8000 ritka elem van 8000 adattárolás S: ahány sorszám van,itt 2200 O: ahány oszlopszám van 2000 Következő: +8000 adattárolás összadat: 3*8000+2200+2000
Adja meg az alábbi kifejezés egy postorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b*4)/c+6-a/(b+6).
+
/ \
/ /
/ \ / \
* c - +
/ \ / \ / \
+ 4 6 a b 6
/ \
a b
Postorder:ab+4*c/6a-b6+/+
Adja meg az alábbi kifejezés egy preorder alakját és a hozzá tartozó bináris fát! A kifejezés: (a+b)*4/((c+6-a/b)+6).
+
/ \
/ 6
/ \
* -
/ \ / \
+ 4 + /
/ \ / \ / \
a b c 6 a b
Preorder: +/*+ab4-+c6/ab6
Hány összehasonlítást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Összehasonlítás 19 db van.
Hány adatmozgatást fog végrehajtani (adatelemek között) a beszúró rendezés az alábbi kiinduló vektor rendezése során? A={3,6,1,5,9,0,4,2,7}
3,6,1,5,9,0,4,2,7
3,1,6,5,9,0,4,2,7
1,3,6,5,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,9,0,4,2,7
1,3,5,6,0,9,4,2,7
1,3,5,0,6,9,4,2,7
1,3,0,5,6,9,4,2,7
1,0,3,5,6,9,4,2,7
0,1,3,5,6,9,4,2,7
0,1,3,5,6,4,9,2,7
0,1,3,5,4,6,9,2,7
0,1,3,4,5,6,9,2,7
0,1,3,4,5,6,2,9,7
0,1,3,4,5,2,6,9,7
0,1,3,4,2,5,6,9,7
0,1,3,2,4,5,6,9,7
0,1,2,3,4,5,6,9,7
0,1,2,3,4,5,6,7,9
Csere 18 db van.
Adott egy bináris keresőfa, melynek postorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 15, 10, 25, 20, 35, 50, 40, 65, 70, 80, 60, 30. Adja meg a fa rajzát! Mi a gyökere a legnagyobb elemszámú kiegyensúlyozott részfának?
30
/ \
20 60
/ \ / \
10 25 40 80
\ / \ /
15 35 50 70
/
65
A legnagyobb elemszámú kiegyensúlyozott részfa gyökere: 40.
Adott egy bináris keresőfa, melynek preorder bejárása az alábbi sorrendben dolgozza fel az elemeit: 10, 5, 8, 30, 20, 15, 25, 50, 40, 35, 45, 60. Adja meg a fa rajzát! Mi a gyökere a legnagyobb magasságú szigorúan bináris részfának?
10
/ \
5 30
\ / \
8 20 50
/ \ / \
15 25 40 60
/ \
35 45
A legnagyobb magasságú szigorúan bináris részfának a gyökere: 30.
Adjon meg egy tetszőleges 6 magasságú, 14 elemű bináris fát, amely gyökerének nincs jobboldali részfája! Adja meg azt a nem-bináris fát is, melynek ez a „binarizált” ábrázolása!
Egy lehetséges megoldás: szerinte
60
/
55
/ \
40 57
/ \ / \
38 45 56 58
/ / \
30 43 47
/ \ /
42 44 46
